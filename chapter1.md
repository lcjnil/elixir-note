# Elixir 笔记一

## 编程时应该关注数据转换

使用面向对象编程的时候，我们考虑的是如何维护状态，但是我们应该关注的是如何转换这些数据。

而 Linux 的管道就是数据转换的一个例子，更重要的是，它可以并行的工作。

函数就是数据转换器。（比如说 React 的，实际上就是 数据 --&gt; UI 的函数）

## 运行 Elixir

可以配置 `~/.iex.exs` 来 配置 `iex`

通过 `.ex` 结尾的一般会被编译成字节码，`.exs` 则会被当做脚本语言来运行。

通过 `elixir xxx.exs` 来运行，在 iex 中，可以用 `c` 来编译运行某个脚本。

用 `h` 可以显示文档，`i` 可以显示变量类型

# 第二章 模式匹配

elixir 中的 `=` 不是赋值，而更像断言。会尝试找到一种方法，使得等号左边等于右边。被称为 **匹配运算符**。

`a = 1` 尝试把字面值常量 1 绑定到 a 上面。

**模式匹配**，只有在值与模式的结构相同，且内部也对应的时候才匹配。比如：`[ a, b ] = [ 1, 2, 3] #匹配失败，因为模式不同`。

用 `_` 来丢弃不相匹配的值。

在匹配过程中，变量一旦被绑定成某个值，那么其余部分就会保持不变。`[ a, a ] = [ 1, 2 ]` 就会匹配失败。

而在下一次匹配的时候，原来的值不会参与匹配，除非打上`^`标记。（Erlang 只允许匹配一次）

# 第三章 不可变性

不可变性：一个变量诞生之后，就不会更改了（函数式编程的重要特性）。

可以在多线程下保持变量的安全。

Elixir 任何转换数据的函数，都会返回一个新的副本。

# 第四章 Elixir 基础

## 类型
###　基本类型

* 整数（可以用 `_` 分组，而且没有大小限制）
* 浮点数
* 原子（用冒号开头，后面跟原子单词或者运算符），原子的名字就是它的值，同名的原子是相等的。
* 区间（开始..结束）
* 正则表达式 ~r{regexp}

### 系统类型

* PID 和 端口
* 引用

### 特有的类型

#### Collection　类型：
* 元祖 Tuple（花括号，用逗号隔开，通常函数在不出错的时候会返回一个元祖，第一个是 `:ok`），一般只有 2 ~ 4 个元素
* 列表 List （可以 `++` 连接，`--` 差集，`in` 属于），列表是一个类似于链表的结构，意味着获取第 n 个元素的代价很高
* 列表可以可以创建关键字列表（一个列表，里面是键值对）

  ```
   [ name: "dave", city: "Beijing" ]

   [ { :name, "dave" }, { :city, "Beijing" } ]
   # 两者意义相同
   # 并且出现在最后一个参数，可以省略 []
  ```

* 散列表 `%{ "name" => "lcj", "age" => 21 }`，键和值可以是任何东西，如果键是原子，还可以简写 `%{ name: "lcj", age: 16 } `，可以通过括号来访问散列表，如果是原子类型，还可以用点

#### 其他类型
* 二进制型，用`<<>>`包起来

## 约定

- 标识符就是一般的大小写+字母，可以用问号和感叹号结尾
- 模块，记录，协议和行为以大写字母开头，驼峰命名法。其他标识符用小写字母或者下划线开头，并且用下划线分割单词。
- 采用 2 个空格缩进
- # 开头的表示注释
- true 和 false 分别于 `:true` 和 `：false` 对应。只有 nil 和 false 是假。
- 比较运算符的`< >` 和类型有关

## 作用域

词法作用域

通过 with 可以定义一些临时变量


