# Elixir 笔记一

## 编程时应该关注数据转换

使用面向对象编程的时候，我们考虑的是如何维护状态，但是我们应该关注的是如何转换这些数据。

而 Linux 的管道就是数据转换的一个例子，更重要的是，它可以并行的工作。

函数就是数据转换器。（比如说 React 的，实际上就是 数据 --&gt; UI 的函数）

## 运行 Elixir

可以配置 `~/.iex.exs` 来 配置 `iex`

通过 `.ex` 结尾的一般会被编译成字节码，`.exs` 则会被当做脚本语言来运行。

通过 `elixir xxx.exs` 来运行，在 iex 中，可以用 `c` 来编译运行某个脚本。

# 第二章 模式匹配

elixir 中的 `=` 不是赋值，而更像断言。会尝试找到一种方法，使得等号左边等于右边。被称为 **匹配运算符**。

`a = 1` 尝试把字面值常量 1 绑定到 a 上面。

**模式匹配**，只有在值与模式的结构相同，且内部也对应的时候才匹配。比如：`[ a, b ] = [ 1, 2, 3] #匹配失败，因为模式不同`。

用 `_` 来丢弃不相匹配的值。

在匹配过程中，变量一旦被绑定成某个值，那么其余部分就会保持不变。`[ a, a ] = [ 1, 2 ]` 就会匹配失败。

而在下一次匹配的时候，原来的值不会参与匹配，除非打上`^`标记。（Erlang 只允许匹配一次）

# 第三章 不可变性

不可变性：一个变量诞生之后，就不会更改了（函数式编程的重要特性）。

可以在多线程下保持变量的安全。

Elixir 任何转换数据的函数，都会返回一个新的副本。

# Elixir 基础

值类型：

* 整数（可以用 `_` 分组，而且没有大小限制）
* 浮点数
* 原子（用冒号开头，后面跟原子单词或者运算符），原子的名字就是它的值，同名的原子是相等的。
* 区间（开始..结束）
* 正则表达式 ~r{regexp}

系统类型：

* PID 和 端口
* 引用

特有的类型

Collection：

* 元祖 Tuple（花括号，用逗号隔开，通常函数在不出错的时候会返回一个元祖，第一个是 `:ok`）
* 列表 List （可以 `++` 连接，`--` 差集，`in` 属于）
* 列表可以可以创建键值对

  ```
   [ name: "dave", city: "Beijing" ]

   [ { :name, "dave" }, { :city, "Beijing" } ]
   # 两者意义相同
   # 并且出现在最后一个参数，可以省略 []
  ```

* 

